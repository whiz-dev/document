#Virtual Box 네트워크 설정
NAT
어탭터에 브릿지
호스트 전용 어댑터
https://youtu.be/EVdhT4ImEcY

#zookeeper
zkServer.sh start (시작)
zkServer.sh stop (종료)
netstat -antp | grep 2181 (시작확인. zookeeper 포트 확인)
zkCli.sh

#kafka
kafka-server-start.sh $KAFKA/config/server.properties&  (시작. & -> background 실행. daemon으로 실행시 화면에 로그 출력이 안됨)
kafka-server-stop.sh (종료)
netstat -ntlp | grep 9092 (시작확인. kafka 포트 확인)
cat /usr/local/kafka/logs/server.log (서버로그 확인)

#kafka 기본명령어
kafka-topics.sh --create --topic kopo-topic --bootstrap-server master:9092,slave1:9092,slave2:9092 –replication-factor 1 --partitions 1 (토픽생성)
kafka-topics.sh  --bootstrap-server master:9092,slave1:9092,slave2:9092 --alter --topic kopo-topic --partitions 2 (토픽 파티션 갯수 증가)
kafka-topics.sh --describe --topic kopo-topic --bootstrap-server master:9092,slave1:9092,slave2:9092 (토픽정보 보기)
kafka-console-producer.sh --broker-list master:9092,slave1:9092,slave2:9092 --topic kopo-topic (producer 연결)
kafka-console-producer.sh --broker-list master:9092,slave1:9092,slave2:9092 --topic kopo-topic --request-required-acks 1
(ack:0 -> broker가 받았는지 확인 안함, ack:1 -> 리더 broker가 받았는지 확인, ack:all -> leader, follower brocker 모두가 받았는지 확인)
kafka-console-consumer.sh --bootstrap-server master:9092,slave1:9092,slave2:9092 --topic kopo-topic --from-beginning (consumer 연결)
kafka-reassign-partitions.sh --bootstrap-server master:9092,slave1:9092,slave2:9092 --reassignment-json-file ./rf.json --execute (replication-factor 변경)
{"version":1,
"partitions":[
    {"topic":"kopo-topic","partition":0,"replicas":[3,1]}
]}
kafka-consumer-groups.sh --bootstrap-server master:9092,slave1:9092,slave2:9092 --list (comsumer group 목록)
kafka-consumer-groups.sh --bootstrap-server master:9092,slave1:9092,slave2:9092 --group kopo-consumer --describe (comsumer group 정보)

#kafka 서버관리
kafka-configs.sh --bootstrap-server :9092 --entity-type topics --entity-name kopo-topic  --describe --all


하나의 파티션은 하나의 컨슈머에만 연결가능
파티션별로 Leader, Follower 설정 (동일한 토픽내 파티션 별로 Leader, Follower가 다를 수 있음)
send 시 키 값이 있을 경우 특정 파티션으로만 보내진다.
순서 보장이 필요 -> key를 사용하여 특정 파티션으로 전송 -> 파티션 1개만 사용해서 부하분산 안됨 -> redis 와 같은 메모리 DB로 메시지 취합 및 소팅 -> 컨슈머에 순차적으로 전송
auto_offset_reset='latest' : 접속 후 들어오는 메시지부터 읽는다
auto_offset_reset='earliest' : commit되지 가장 오래된 메시지부터 읽는다.













